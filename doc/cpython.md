# CPython internals

Notes on cpython 3.10.0 internals.

# Frames

CPython VM uses frame objects to store the state in which a code object is executed.
A frame is typically created for each new scope, for example when a new function is entered.
The frame stores current local and global variables, VM stack, reference to previous frame and more.

A frame object is implemented as a `_frame` struct:

    struct _frame {
        PyObject_VAR_HEAD
        struct _frame *f_back;      /* previous frame, or NULL */
        PyCodeObject *f_code;       /* code segment */
        PyObject *f_builtins;       /* builtin symbol table (PyDictObject) */
        PyObject *f_globals;        /* global symbol table (PyDictObject) */
        PyObject *f_locals;         /* local symbol table (any mapping) */
        PyObject **f_valuestack;    /* points after the last local */
        PyObject *f_trace;          /* Trace function */
        int f_stackdepth;           /* Depth of value stack */
        char f_trace_lines;         /* Emit per-line trace events? */
        char f_trace_opcodes;       /* Emit per-opcode trace events? */

        /* Borrowed reference to a generator, or NULL */
        PyObject *f_gen;

        int f_lasti;                /* Last instruction if called */
        int f_lineno;               /* Current line number. Only valid if non-zero */
        int f_iblock;               /* index in f_blockstack */
        PyFrameState f_state;       /* What state the frame is in */
        PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */
        PyObject *f_localsplus[1];  /* locals+stack, dynamically sized */
    };

Note that frame object is type aliased as `PyFrameObject`.
A limited API for frame object is defined in `pyframe.h`.

For more detailed description of frame and code objects see:
[Python behind the scenes #1: how the CPython VM works](https://tenthousandmeters.com/blog/python-behind-the-scenes-1-how-the-cpython-vm-works/)

## Local Symbols

The frame's local symbols are stored in `f_locals` object or in the `f_localsplus` array.
The `f_localsplus` arrays is used for cases of optimized symbols access.

When optimized mode is used is dictated by the byte code generated by the compiler.
The frame's byte code is stored in the PyCodeObject, accessible via `f_code` member.
The code object's `co_flags` will have it's `CO_OPTIMIZED` bit set, when optimized mode is used.

### `f_locals` method

For the unoptimized case, `f_locals` member points to a container python object.
The container provides access to the local symbols by name.
It will map symbol's name to a reference of the symbol's value.
The container object type is not specified, but it will support the [Mapping Protocol](https://docs.python.org/3/c-api/mapping.html).

#### Example

Below is an example when `f_locals` method is used.
Following code assigns a value to a local variable at module scope:

    #!/usr/bin/env python
    x = 42

This will generate following byte code:

    2           0 LOAD_CONST               0 (42)
                2 STORE_NAME               0 (x)

The `LOAD_CONST` instruction pushes `42` to the VM's stack.
The `STORE_NAME` pops the stack, and stores that value at `f_locals["x"]` slot.
Note that `"x"` string will be fetched from the `co_names` attribute of the frame's code object.

For more details, see [STORE_NAME](https://docs.python.org/3/library/dis.html#opcode-STORE_NAME) documentation.

### `f_localsplus` method

When local symbols access is optimized, first part of the `f_localsplus` array is used for local symbols storage.
Instead of accessing symbols by name, compiler assigns a fixed index number to each local symbol.
The symbol's index is used to access it's reference stored in `f_localsplus` array.

The code object's `co_nlocals` is set to the number of local symbols for that code block.
Thus first `co_nlocals` elements of the frame's  `f_localsplus` array will be used for storing local symbols.

#### Example

Below is an example when `f_localsplus` method is used.
Following function assigns a value to it's local variable:

    def func():
        x = 42

This will generate following byte code, using optimized style:

    2           0 LOAD_CONST               1 (42)
                2 STORE_FAST               0 (x)

The `LOAD_CONST` instruction pushes `42` to the VM's stack.
The `STORE_FAST` pops the stack, and stores that value at `f_localsplus[0]` slot.
Note, that here we don't fetch variable's name `"x"`, but we use it's index directly.

For more details, see [STORE_FAST](https://docs.python.org/3/library/dis.html#opcode-STORE_FAST) documentation.

### Python API

The CPython provides access to local symbols of a frame object from python code.
The `sys._getframe()` function returns the frame object for the requested level of the call stack.

That frame object have `f_locals` field.
Note that when accessing `f_locals` from python, symbols stored in `f_localsplus` will be merged into `f_locals` object.
See `frame_getlocals()` function in `Objects/frameobject.c` for details.

This merging behaviour, means that python code only have read access for symbols from `f_localsplus`.
This is due to the fact none of that changes to `f_locals` will propogate to `f_localsplus` array.
